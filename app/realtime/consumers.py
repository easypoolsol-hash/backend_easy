"""WebSocket consumers for real-time updates."""

import json

from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer


class DashboardConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer for real-time dashboard updates.

    Used by: School admin dashboard
    Channel: "dashboard_updates" - receives boarding events

    Pushes:
    - New boarding events (student boarded)
    - Updated statistics (student count, etc.)
    """

    async def connect(self):
        """Handle WebSocket connection."""
        # Check authentication
        if not await self.is_authenticated():
            await self.close(code=4001)
            return

        # Join dashboard updates group
        self.group_name = "dashboard_updates"
        await self.channel_layer.group_add(self.group_name, self.channel_name)

        await self.accept()

    async def disconnect(self, close_code):
        """Handle WebSocket disconnection."""
        if hasattr(self, "group_name"):
            await self.channel_layer.group_discard(self.group_name, self.channel_name)

    async def receive(self, text_data):
        """Handle messages from WebSocket client (not used - server push only)."""
        pass

    async def boarding_event(self, event):
        """
        Receive boarding event from channel layer and push to client.

        Event format:
        {
            'type': 'boarding_event',
            'event_id': str,
            'student_id': str,
            'student_name': str,
            'grade': str,
            'timestamp': str (ISO format),
            'kiosk_id': str,
            'event_type': str
        }
        """
        await self.send(
            text_data=json.dumps(
                {
                    "type": "boarding_event",
                    "data": {
                        "event_id": event["event_id"],
                        "student_id": event["student_id"],
                        "student_name": event["student_name"],
                        "grade": event["grade"],
                        "timestamp": event["timestamp"],
                        "kiosk_id": event["kiosk_id"],
                        "event_type": event["event_type"],
                    },
                }
            )
        )

    async def dashboard_stats(self, event):
        """
        Receive dashboard stats update from channel layer.

        Event format:
        {
            'type': 'dashboard_stats',
            'students_boarded_today': int,
            'total_events_today': int,
        }
        """
        await self.send(
            text_data=json.dumps(
                {
                    "type": "stats_update",
                    "data": {
                        "students_boarded_today": event["students_boarded_today"],
                        "total_events_today": event["total_events_today"],
                    },
                }
            )
        )

    @database_sync_to_async
    def is_authenticated(self):
        """Check if user is authenticated and is school admin."""
        user = self.scope.get("user")
        if not user or not user.is_authenticated:
            return False
        # Only school admins can access dashboard
        return user.groups.filter(name="School Administrator").exists()


class BusTrackingConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer for real-time bus location updates.

    Used by:
    - School dashboard (admin monitoring)
    - Parent app (track child's bus)
    - Future: Driver app, fleet management

    Channel: "bus_updates" - receives GPS location changes
    """

    async def connect(self):
        """Handle WebSocket connection."""
        # Check authentication
        if not await self.is_authenticated():
            await self.close(code=4001)
            return

        # Join bus updates group
        # IMPORTANT: self.channel_name is auto-generated by Channels (unique per connection)
        # group_name is the broadcast channel we want to join
        self.group_name = "bus_updates"
        await self.channel_layer.group_add(
            self.group_name,  # Group to join
            self.channel_name,  # This connection's unique channel name
        )

        await self.accept()

        # Send initial bus locations to newly connected client
        await self.send_initial_bus_locations()

    async def disconnect(self, close_code):
        """Handle WebSocket disconnection."""
        # Leave bus updates group safely
        if hasattr(self, "group_name"):
            await self.channel_layer.group_discard(
                self.group_name,  # Group to leave
                self.channel_name,  # This connection's unique channel name
            )

    async def receive(self, text_data):
        """
        Handle messages from WebSocket client.

        Currently not used - server pushes data only.
        Future: Could handle client filters (specific bus, route).
        """
        pass

    async def bus_location_update(self, event):
        """
        Receive bus location update from channel layer.
        Push to WebSocket client.

        Event format:
        {
            'type': 'bus_location_update',
            'bus_id': str,
            'license_plate': str,
            'latitude': float,
            'longitude': float,
            'speed': float,
            'heading': float,
            'status': str,
            'timestamp': str (ISO format)
        }
        """
        # Send to WebSocket client
        await self.send(
            text_data=json.dumps(
                {
                    "type": "location_update",
                    "data": {
                        "bus_id": event["bus_id"],
                        "license_plate": event["license_plate"],
                        "latitude": event["latitude"],
                        "longitude": event["longitude"],
                        "speed": event["speed"],
                        "heading": event["heading"],
                        "status": event.get("status", "unknown"),
                        "timestamp": event["timestamp"],
                    },
                }
            )
        )

    @database_sync_to_async
    def is_authenticated(self):
        """Check if user is authenticated."""
        user = self.scope.get("user")
        if not user:
            return False
        return user.is_authenticated

    @database_sync_to_async
    def get_initial_bus_locations(self):
        """Fetch all current bus locations as GeoJSON features."""
        from django.db.models import Max

        from kiosks.models import BusLocation

        # Get latest location for each kiosk
        latest_locations = BusLocation.objects.values("kiosk_id").annotate(
            latest_timestamp=Max("timestamp")
        )

        features = []
        for loc_data in latest_locations:
            location = (
                BusLocation.objects.filter(
                    kiosk_id=loc_data["kiosk_id"],
                    timestamp=loc_data["latest_timestamp"],
                )
                .select_related("kiosk__bus__route")
                .first()
            )

            if location and location.kiosk and location.kiosk.bus:
                kiosk = location.kiosk
                bus = kiosk.bus

                features.append(
                    {
                        "type": "Feature",
                        "geometry": {
                            "type": "Point",
                            "coordinates": [
                                float(location.longitude),
                                float(location.latitude),
                            ],
                        },
                        "properties": {
                            "id": str(bus.bus_id),
                            "name": bus.license_plate,
                            "status": bus.status,
                            "last_location_update": location.timestamp.isoformat(),
                            "speed": float(location.speed) if location.speed else 0,
                            "heading": float(location.heading) if location.heading else 0,
                        },
                    }
                )

        return features

    async def send_initial_bus_locations(self):
        """Send current bus locations to newly connected client."""
        features = await self.get_initial_bus_locations()

        await self.send(
            text_data=json.dumps({"type": "bus_location_update", "features": features})
        )
