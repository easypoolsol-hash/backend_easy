# Docker Compose for CI Testing
# Contains only the services needed for running tests in CI

services:
  # PostgreSQL Database for Testing
  postgres:
    image: postgres:15
    container_name: test_postgres
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: test_db
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - test_network

  # Redis for Testing
  redis:
    image: redis:7
    container_name: test_redis
    command: redis-server --appendonly yes
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - test_network

  # Web service used to run manage.py / tests inside the same network and env
  web:
    build:
      context: .
      dockerfile: Dockerfile
    image: backend_easy:test
    container_name: test_web
    working_dir: /app
    command: daphne -b 0.0.0.0 -p 8000 bus_kiosk_backend.asgi:application
    volumes:
      # Mount only the `app/` directory into /app so the container sees
      # `manage.py` at `/app/manage.py`. Mounting the repo root here would
      # place the `app/` directory at `/app/app/` which breaks `python manage.py`.
      - ./app:/app:cached
      # Ensure the ml_models package from the repo root is available inside
      # the container at /app/ml_models. Without this bind-mount the image's
      # copied /app/ml_models can be hidden by the ./app:/app volume.
      - ./ml_models:/app/ml_models:cached
    environment:
      # Application / test configuration (kept here so CI YAML stays clean)
      DEBUG: 'true'
      SECRET_KEY: test-secret-key-for-testing-only
  # ENCRYPTION_KEY should be provided by the runner environment or tests.
  # Do NOT hardcode production keys in source.
      DB_ENGINE: django.db.backends.postgresql
      DB_NAME: test_db
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_HOST: postgres
      DB_PORT: 5432
      REDIS_URL: redis://redis:6379/0
      CELERY_BROKER_URL: redis://redis:6379/0
      CELERY_RESULT_BACKEND: redis://redis:6379/0
      USE_FILE_LOGGING: 'false'  # Console-only logging for CI/tests
    ports:
      # Publish web port so tests running on the CI runner can access the container
      - "8000:8000"
    # Ensure web starts after postgres and redis are started
    depends_on:
      - postgres
      - redis
    networks:
      - test_network

  # Celery worker (SAME image as web, different command)
  celery_worker:
    image: backend_easy:test
    container_name: test_celery_worker
    working_dir: /app
    command: celery -A bus_kiosk_backend worker --loglevel=info
    volumes:
      - ./app:/app:cached
      - ./ml_models:/app/ml_models:cached
    environment:
      DEBUG: 'true'
      SECRET_KEY: test-secret-key-for-testing-only
      DB_ENGINE: django.db.backends.postgresql
      DB_NAME: test_db
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_HOST: postgres
      DB_PORT: 5432
      REDIS_URL: redis://redis:6379/0
      CELERY_BROKER_URL: redis://redis:6379/0
      CELERY_RESULT_BACKEND: redis://redis:6379/0
      USE_FILE_LOGGING: 'false'  # Console-only logging for CI/tests
    depends_on:
      - postgres
      - redis
    networks:
      - test_network

networks:
  test_network:
    driver: bridge
